<!-- Manage external imports -->
<link rel="import" href="../polymer/polymer.html">
<script type="text/javascript" src="../d3/d3.min.js"></script>

<!--
`<tf-editor>`
A Web based volume rendering transfer function editor

Typical use, just insert `<tf-editor>` along a volume rendering scene into your
page and then pass the volume data as a flatten array as an input.

    <body>
      <tf-editor id="TF"></tf-editor>
    </body>

The output canvas selector string will be reflected in the `output` attribute.

@demo ./demo/index.html  Showcase of the different attribute arguments!
@demo ./demo/demo1.html  Super cool demo, TF with volume rendering exanple!
@demo ./demo/demo2.html  Even cooler demo. TF with DICOM and rescale example!
-->
<dom-module id="tf-editor">
    <template>
    <style>
      :host {
        display: block;
      }

      .bar rect {
        fill: steelblue;
      }

      rect {
        fill: none;
        pointer-events: all;
      }

      .line {
        /*fill: steelblue;*/
        stroke: black;
        stroke-width: 1.5px;
      }

      circle {
        /*fill: #fff;*/
        fill-opacity: .6;
        cursor: move;
        stroke: black;
        stroke-width: 1.5px;
      }

      .selected {
        fill: #ff7f0e;
        stroke: #ff7f0e;
      }
    </style>
    <div id="container">
      <svg id="svg-{{id}}" width$="{{width}}" height$="{{height}}"></svg>
      <input type="color" id="picker-{{id}}"><canvas id="canvas-{{id}}" width="255" height="10"></canvas>
    </div>
  </template>

    <script>
        Polymer({

            is: 'tf-editor',

            _createElements: function() {
                // Custom margins
                this.margin = {
                    top: 10,
                    right: 20,
                    bottom: 20,
                    left: 25
                };
                this.formatCount = d3.format(",.0f");

                // Axis scales
                this.xScale = d3.scaleLinear();
                this.yScale = d3.scaleLinear();
                this.binScale = d3.scaleLinear();

                // Area for the opacity map representation
                this.area = d3.area();

                // Create histogram object
                this.bins = d3.histogram();

                // Control points
                this.controlPoints = [];

                // Scale to fit the gradient in the canvas output
                this.canvasScale = d3.scaleLinear();

                // Keep track of control points interaction
                this.dragged = null,
                    this.selected = null;
                this.last_color = 'green';
            },

            _initializeElements: function() {
                var extent = d3.extent(this._data);
                var me = this;
                this.xScale
                    .rangeRound([0, this._width])
                    .domain(extent);
                this.yScale
                    .domain([0, 1])
                    .range([this._height, 0]);
                this.binScale
                    .range([this._height, 0]);
                this.bins
                    .domain(this.xScale.domain())
                    .thresholds(this.xScale.ticks(this.nbins));
                this.controlPoints.push({
                    'x': extent[0],
                    'opacity': 0,
                    'color': 'blue'
                });
                this.controlPoints.push({
                    'x': extent[1],
                    'opacity': 1,
                    'color': 'red'
                });
                this.selected = this.controlPoints[0];
                this.area
                    .x(function(d) {
                        return me.xScale(d.x);
                    })
                    .y0(function(d) {
                        return me.yScale(d.opacity);
                    })
                    .y1(this._height)
                    .curve(d3.curveLinear);

                this.canvasScale.range([0, 1]);
                // Get the context of the canvas element
                this.canvasContext = this.$$("canvas").getContext("2d");
                // Access the color selector
                this.$$("#picker-" + this.id).addEventListener("change", function() {
                    me.last_color = this.value;
                });
            },

            // Perform the drawing
            _drawChart: function() {
                var me = this;
                var g = this.svg.append("g")
                    .attr("transform", "translate(" + this.margin.left + "," + this.margin.top + ")");

                // Add data to compute the histogram
                var bins = this.bins(this._data);
                this.binScale.domain([0, d3.max(bins, function(d) {
                    return d.length;
                })])

                // Draw hitogram as a refence point
                var bar = g.selectAll(".bar")
                    .data(bins)
                    .enter().append("g")
                    .attr("class", "bar")
                    .attr("transform", function(d) {
                        return "translate(" + me.xScale(d.x0) + "," + me.binScale(d.length) + ")";
                    });

                bar.append("rect")
                    .attr("x", 1)
                    .attr("width", this.xScale(bins[0].x1) - this.xScale(bins[0].x0) - 1)
                    .attr("height", function(d) {
                        return me._height - me.binScale(d.length);
                    });

                // Gradient definitions
                g.append("defs").append("linearGradient")
                    .attr("id", "tfGradient-" + this.id)
                    //.attr("gradientUnits", "userSpaceOnUse")
                    .attr("gradientUnits", "objectBoundingBox")
                    .attr("spreadMethod", "pad")
                    .attr("x1", "0%").attr("y1", "0%")
                    .attr("x2", "100%").attr("y2", "0%");
                //.attr("x1", me.xScale(0)).attr("y1", me.yScale(0))
                //.attr("x2", me.xScale(255)).attr("y2", me.yScale(0));

                // Draw control points
                g.append("path")
                    .datum(me.controlPoints)
                    .attr("class", "line")
                    .attr("fill", "url(#tfGradient-" + this.id + ")")
                    .attr("stroke", "black")
                    .call(function() {
                        var _that = me;
                        me._redraw.call(_that);
                    });

                g.append("rect")
                    .attr("width", me._width)
                    .attr("height", me._height)
                    .style("opacity", 0)
                    .on("mousedown", function() {
                        var _that = me;
                        me._mousedown.call(_that);
                    })
                    .on("mouseup", function() {
                        var _that = me;
                        me._mouseup.call(_that);
                    })
                    .on("mousemove", function() {
                        var _that = me;
                        me._mousemove.call(_that);
                    });

                d3.select(me.$$('svg')).on("keydown", function() {
                    var _that = me;
                    me._keydown.call(_that);
                });

                // Draw axis
                g.append("g")
                    .attr("class", "axis axis--x")
                    .attr("transform", "translate(0," + me._height + ")")
                    .call(d3.axisBottom(me.xScale).ticks(this.nticks));

                g.append("g")
                    .attr("class", "axis axis--y")
                    .attr("transform", "translate(0, 0)")
                    .call(d3.axisLeft(me.yScale).ticks(this.nticks));
            },

            // Update the chart content
            _redraw: function() {
                var me = this;
                var svg = d3.select(me.$$('svg')).select("g");
                svg.select("path").attr("d", me.area);

                // Add circle to connect and interact with the control points
                var circle = svg.selectAll("circle")
                    .data(me.controlPoints)

                circle.enter().append("circle")
                    .attr("cx", function(d) {
                        return me.xScale(d.x);
                    })
                    .attr("cy", function(d) {
                        return me.yScale(d.opacity);
                    })
                    .style("fill", function(d) {
                        return d.color;
                    })
                    .attr("r", 1e-6)
                    .on("mousedown", function(d) {
                        var _that = me;
                        me.selected = me.dragged = d;
                        me.last_color = d.color;
                        me._redraw.call(_that);
                    })
                    .on("mouseup", function() {
                        var _that = me;
                        me._mouseup.call(_that);
                    })
                    .on("contextmenu", function(d, i) {
                        // react on right-clicking
                        d3.event.preventDefault();
                        d.color = me.$$("#picker-" + me.id).value;
                        me._redraw.call(me);
                    })
                    .transition()
                    .duration(750)
                    .attr("r", 5.0);

                circle.classed("selected", function(d) {
                        return d === me.selected;
                    })
                    .style("fill", function(d) {
                        return d.color;
                    })
                    .attr("cx", function(d) {
                        return me.xScale(d.x);
                    })
                    .attr("cy", function(d) {
                        return me.yScale(d.opacity);
                    })
                    .raise();

                circle.exit().remove();

                // Create a linear gradient definition of the control points
                var gradient = svg.select("linearGradient").selectAll("stop").data(me.controlPoints);

                gradient.enter().append("stop")
                    .attr("stop-color", function(d) {
                        return d.color;
                    })
                    .attr("stop-opacity", function(d) {
                        return d.opacity;
                    })
                    .attr("offset", function(d) {
                        var l = (me.controlPoints[me.controlPoints.length - 1].x - me.controlPoints[0].x);
                        return "" + ((d.x - me.controlPoints[0].x) / l * 100) + "%";
                    });

                gradient.attr("stop-color", function(d) {
                        return d.color;
                    })
                    .attr("stop-opacity", function(d) {
                        return d.opacity;
                    })
                    .attr("offset", function(d) {
                        var l = (me.controlPoints[me.controlPoints.length - 1].x - me.controlPoints[0].x);
                        return "" + ((d.x - me.controlPoints[0].x) / l * 100) + "%";
                    });

                gradient.exit().remove();

                if (d3.event) {
                    d3.event.preventDefault();
                    d3.event.stopPropagation();
                }

                // Draw gradient in canvas too
                setTimeout(function() {
                    me._drawCanvas();
                }, 100);
            },

            /**
             * Draw the TF output in the canvas container.
             */
            _drawCanvas: function() {
                //var me = this;
                var extent = [d3.min(this.controlPoints, function(d) {
                        return d.x;
                    }),
                    d3.max(this.controlPoints, function(d) {
                        return d.x;
                    })
                ];
                this.canvasScale.domain(extent);
                // Convinient access
                var x0 = extent[0],
                    x1 = extent[1];
                var ctx = this.canvasContext;
                // Clear previous result
                ctx.clearRect(0, 0, 255, 10);
                // Draw new result
                var grd = ctx.createLinearGradient(x0, 0, x1, 0);
                for (var i = 0; i < this.controlPoints.length; i++) {
                  var d = this.controlPoints[i];
                  var color = d3.color(d.color);
                  color.opacity = d.opacity;
                  //grd.addColorStop((d.x - x0) / Math.abs(x1 - x0), color.toString());
                  grd.addColorStop(this.canvasScale(d.x), color.toString());
                }
                ctx.fillStyle = grd;
                ctx.fillRect(x0, 0, x1-x0, 10);
            },

            /////// User interaction related event callbacks ////////

            _mousedown: function() {
                var me = this;
                var pos = d3.mouse(me.svg.node());
                point = {
                    "x": me.xScale.invert(pos[0] - me.margin.left),
                    "opacity": me.yScale.invert(pos[1] - me.margin.top),
                    "color": me.last_color
                };
                me.selected = me.dragged = point;
                var bisect = d3.bisector(function(a, b) {
                    return a.x - b.x;
                }).left;
                var indexPos = bisect(me.controlPoints, point);
                me.controlPoints.splice(indexPos, 0, point);
                me._redraw();
            },

            _mousemove: function() {
                if (!this.dragged) return;
                var index = this.controlPoints.indexOf(this.selected);
                var m = d3.mouse(this.svg.node());
                this.dragged.x = this.xScale.invert(Math.max(0, Math.min(this._width, m[0] - this.margin.left)));
                this.dragged.opacity = this.yScale.invert(Math.max(0, Math.min(this._height, m[1] - this.margin.top)));
                var bisect = d3.bisector(function(a, b) {
                    return a.x - b.x;
                }).left;
                var bisect2 = d3.bisector(function(a, b) {
                    return a.x - b.x;
                }).right;
                var virtualIndex = bisect(this.controlPoints, this.dragged);
                var virtualIndex2 = bisect2(this.controlPoints, this.dragged);
                if (virtualIndex < index) {
                    this.controlPoints.splice(virtualIndex, 1);
                } else if (virtualIndex > index) {
                    this.controlPoints.splice(index + 1, 1);
                } else if (virtualIndex2 - index >= 2) {
                    this.controlPoints.splice(index + 1, 1);
                }
                this._redraw();
            },

            _mouseup: function() {
                if (!this.dragged) return;
                this._redraw();
                this.dragged = null;
            },

            _keydown: function() {
                if (!this.selected) return;
                switch (d3.event.keyCode) {
                    case 46:
                        { // delete
                            var i = this.controlPoints.indexOf(this.selected);
                            this.controlPoints.splice(i, 1);
                            this.selected = this.controlPoints.length ? this.controlPoints[i > 0 ? i - 1 : 0] : null;
                            this._redraw();
                            break;
                        }
                }
            },

            /////// Public API functions ///////

            /**
             * Get the TF output canvas `element`.
             *
             * @return {HTMLElement} canvas 2D with the TF output.
             */
            getCanvas: function() {
                return this.$$("#canvas-" + this.id)
            },
            /**
             * Get the output canvas `element` query selector.
             *
             * @return {CSSselector}
             */
            getCanvasSelector: function() {
                return "#canvas-" + this.id
            },
            /**
             * Set the output canvas `element`.
             *
             * @param {HTMLElement} element canvas 2D.
             * @return {bool}
             */
            setCanvas: function(element) {
                return false;
            },
            /**
             * Set the output canvas `element`.
             *
             * @param {Array} d
             */
            setData: function(d) {},

            /////// Polymer lifecycle callbacks /////////////

            // Create elements when loaded into DOM not initialized
            created: function() {
                this._createElements();
            },

            // Initialize elements and perform the drawing of first drawing
            ready: function() {
                this.scopeSubtree(this.$.container, true);
                // Access the svg dom element
                this.svg = d3.select(this.$$('svg'));
                this._width = +this.svg.attr("width") - this.margin.left - this.margin.right;
                this._height = +this.svg.attr("height") - this.margin.top - this.margin.bottom - 15;
                // Create ramdom test data
                this._data = d3.range(1000).map(function() {
                    return Math.random() * 255 | 0;
                });
                //this._data = d3.range(1000).map(d3.randomBates(10));
                this._initializeElements();
                this._drawChart();
            },

            // Define Polymer component properties
            properties: {
                /**
                 * Unique identifier for the dom element.
                 *
                 * @type {String}
                 */
                id: {
                    type: String,
                    value: 'tf-1',
                },
                /**
                 * Metadata describing a nome for the element (Optional).
                 *
                 * @type {String}
                 */
                name: {
                    type: String,
                    value: 'TF-Editor',
                },
                /**
                 * CSSselector to an ImageTextureAtlas node from the X3DOM Framework (Optional).
                 *
                 * @type {CSSselector}
                 */
                x3domAtlasSelector: {
                    type: String
                },
                /**
                 * Explicit selector to an existent canvas (Optional).
                 * The referenced canvas must have a minimun width of 256
                 * pixels and 1 pixel height.
                 *
                 * @type {CSSselector}
                 */
                canvasSelector: {
                    type: String
                },
                /**
                 * Explicit width fot the element (Optional).
                 *
                 * @type {Number}
                 */
                width: {
                    type: Number,
                    value: 375,
                },
                /**
                 * Explicit height fot the element (Optional).
                 *
                 * @type {Number}
                 */
                height: {
                    type: Number,
                    value: 200,
                },
                /**
                 * The number of bins to represent the histogram of the input data.
                 *
                 * @type {Number}
                 */
                nbins: {
                    type: Number,
                    value: 100,
                },
                /**
                 * The number of ticks to be displayed in the axis.
                 *
                 * @type {Number}
                 */
                nticks: {
                    type: Number,
                    value: 4,
                }
                // /**
                //  * Interpolation method to be used.
                //  *
                //  * @type {String}
                //  */
                // interpolate: {
                //     type: String,
                //     value: "linear"
                // }
            },

        });
    </script>
</dom-module>
