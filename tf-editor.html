<!-- Manage external imports -->
<link rel="import" href="../polymer/polymer.html">
<script type="text/javascript" src="../d3/d3.min.js"></script>

<!--
`<tf-editor>`
A Web based volume rendering transfer function editor

Typical use, just insert `<tf-editor>` along a volume rendering scene into your
page and then pass the volume data as a flatten array as an input.

    <body>
      <tf-editor id="TF"></tf-editor>
    </body>

The output canvas selector string will be reflected in the `output` attribute.
@demo ./demo/demo1.html  Super cool demo, TF with volume rendering exanple!
@demo ./demo/index.html  Showcase of the different attribute arguments!

@demo ./demo/demo2.html  Even cooler demo. TF with DICOM and rescale example!
-->
<dom-module id="tf-editor">
    <template>
    <style>
      :host {
        display: block;
      }

      .bar rect {
        fill: steelblue;
      }

      rect {
        fill: none;
        pointer-events: all;
      }

      .line {
        /*fill: steelblue;*/
        stroke: black;
        stroke-width: 1.5px;
      }

      circle {
        /*fill: #fff;*/
        fill-opacity: .6;
        cursor: move;
        stroke: black;
        stroke-width: 1.5px;
      }

      .selected {
        fill: #ff7f0e;
        stroke: #ff7f0e;
      }
    </style>
    <div id="container">
      <svg id="svg-{{id}}" width$="{{width}}" height$="{{height}}"></svg>
      <input type="color" id="picker-{{id}}">
      <template is="dom-if" if="{{_external}}">
        <canvas id="canvas-{{id}}" width="255" height="10"></canvas>
      </template>
    </div>
    </template>

    <script>
        Polymer({

            is: 'tf-editor',

            _createElements: function() {
                // Custom margins
                this.margin = {
                    top: 10,
                    right: 20,
                    bottom: 20,
                    left: 25
                };
                this.formatCount = d3.format(",.0f");

                // Axis scales
                this.xScale = d3.scaleLinear();
                this.yScale = d3.scaleLinear();
                this.binScale = d3.scaleLinear();

                // Area for the opacity map representation
                this.area = d3.area();

                // Create histogram object
                this.bins = d3.histogram();

                // Control points
                // this.controlPoints = [];

                // Scale to fit the gradient in the canvas output
                this.canvasScale = d3.scaleLinear();

                // Keep track of control points interaction
                this.dragged = null;
                this.selected = null;
                this.last_color = 'green';
            },

            _initializeElements: function() {
                var extent = d3.extent(this._data);
                var me = this;
                this.xScale
                    .rangeRound([0, this._width])
                    .domain(extent);
                this.yScale
                    .domain([0, 1])
                    .range([this._height, 0]);
                this.binScale
                    .range([this._height, 0]);
                this.bins
                    .domain(this.xScale.domain())
                    .thresholds(this.xScale.ticks(this.numberBins));
                if (this.controlPoints.length == 0) {
                    this.push('controlPoints', {
                        'x': extent[0],
                        'opacity': 0,
                        'color': 'blue'
                    });
                    this.push('controlPoints', {
                        'x': extent[1],
                        'opacity': 1,
                        'color': 'red'
                    });
                }
                this.selected = this.controlPoints[0];
                this.area
                    .x(function(d) {
                        return me.xScale(d.x);
                    })
                    .y0(function(d) {
                        return me.yScale(d.opacity);
                    })
                    .y1(this._height)
                    .curve(d3.curveLinear);

                this.canvasScale.range([0, 1]);

                // Canvas element selector to output the result
                this.canvasselector = this.canvasselector || "#canvas-" + this.id;
                // Get the context of the canvas element
                this.canvasContext = function() {
                    if (me._external == true) {
                        return me.$$(me.canvasselector).getContext("2d");
                    } else {
                        return document.querySelector(me.canvasselector).getContext("2d");
                    }
                };
                // Access the color selector
                this.$$("#picker-" + this.id).addEventListener("change", function() {
                    me.last_color = this.value;
                });
            },

            // Perform the drawing
            _drawChart: function() {
                var me = this;
                var g = this.svg.append("g")
                    .attr("transform", "translate(" + this.margin.left + "," + this.margin.top + ")");

                // Draw initial histogram
                this._redrawHistogram();

                // Gradient definitions
                g.append("defs").append("linearGradient")
                    .attr("id", "tfGradient-" + this.id)
                    //.attr("gradientUnits", "userSpaceOnUse")
                    .attr("gradientUnits", "objectBoundingBox")
                    .attr("spreadMethod", "pad")
                    .attr("x1", "0%").attr("y1", "0%")
                    .attr("x2", "100%").attr("y2", "0%");
                //.attr("x1", me.xScale(0)).attr("y1", me.yScale(0))
                //.attr("x2", me.xScale(255)).attr("y2", me.yScale(0));

                // Draw control points
                g.append("path")
                    .datum(me.controlPoints)
                    .attr("class", "line")
                    .attr("fill", "url(#tfGradient-" + this.id + ")")
                    .attr("stroke", "black")
                    .call(function() {
                        me._redraw();
                    });

                g.append("rect")
                    .attr("width", me._width)
                    .attr("height", me._height)
                    .style("opacity", 0)
                    .on("mousedown", function() {
                        me._mousedown();
                    })
                    .on("mouseup", function() {
                        me._mouseup();
                    })
                    .on("mousemove", function() {
                        me._mousemove();
                    });

                // d3.select(me.$$('svg')).on("keydown", function() {
                //     var _that = me;
                //     me._keydown.call(_that);
                // });

                // Draw axis
                g.append("g")
                    .attr("class", "axis axis--x")
                    .attr("transform", "translate(0," + me._height + ")")
                    .call(d3.axisBottom(me.xScale).ticks(this.numberTicks));

                g.append("g")
                    .attr("class", "axis axis--y")
                    .attr("transform", "translate(0, 0)")
                    .call(d3.axisLeft(me.yScale).ticks(this.numberTicks));
            },

            // update scales with new data input
            _updateScales: function() {

            },

            // update the chart data
            _redrawHistogram: function() {
                var me = this;
                var bins = this.bins(this._data);
                this.binScale.domain([0, d3.max(bins, function(d) {
                    return d.length;
                })]);

                this.svg.select("g").selectAll(".bar").remove();
                var bar = this.svg.select("g").selectAll(".bar").data(bins);
                var barEnter = bar.enter().append("g")
                    .attr("class", "bar")
                    .attr("transform", function(d) {
                        return "translate(" + me.xScale(d.x0) + "," + me.binScale(d.length) + ")";
                    });

                barEnter.append("rect")
                    .attr("x", 1)
                    .attr("width", this.xScale(bins[0].x1) - this.xScale(bins[0].x0) - 1)
                    .attr("height", function(d) {
                        return me._height - me.binScale(d.length);
                    });

                this.svg.select("g").selectAll(".bar").lower();

                bar.exit().remove();

            },

            // Update the chart content
            _redraw: function() {
                var me = this;
                var svg = d3.select(me.$$('svg')).select("g");
                svg.select("path").datum(me.controlPoints).attr("d", me.area);

                // Add circle to connect and interact with the control points
                var circle = svg.selectAll("circle").data(me.controlPoints)

                circle.enter().append("circle")
                    .attr("cx", function(d) {
                        return me.xScale(d.x);
                    })
                    .attr("cy", function(d) {
                        return me.yScale(d.opacity);
                    })
                    .style("fill", function(d) {
                        return d.color;
                    })
                    .attr("r", 1e-6)
                    .on("mousedown", function(d) {
                        me.selected = me.dragged = d;
                        me.last_color = d.color;
                        me._redraw();
                    })
                    .on("mouseup", function() {
                        me._mouseup();
                    })
                    .on("contextmenu", function(d, i) {
                        // react on right-clicking
                        d3.event.preventDefault();
                        d.color = me.$$("#picker-" + me.id).value;
                        me._redraw();
                    })
                    .transition()
                    .duration(750)
                    .attr("r", 5.0);

                circle.classed("selected", function(d) {
                        return d === me.selected;
                    })
                    .style("fill", function(d) {
                        return d.color;
                    })
                    .attr("cx", function(d) {
                        return me.xScale(d.x);
                    })
                    .attr("cy", function(d) {
                        return me.yScale(d.opacity);
                    })
                    .raise();

                circle.exit().remove();

                // Create a linear gradient definition of the control points
                var gradient = svg.select("linearGradient").selectAll("stop").data(me.controlPoints);

                gradient.enter().append("stop")
                    .attr("stop-color", function(d) {
                        return d.color;
                    })
                    .attr("stop-opacity", function(d) {
                        return d.opacity;
                    })
                    .attr("offset", function(d) {
                        var l = (me.controlPoints[me.controlPoints.length - 1].x - me.controlPoints[0].x);
                        return "" + ((d.x - me.controlPoints[0].x) / l * 100) + "%";
                    });

                gradient.attr("stop-color", function(d) {
                        return d.color;
                    })
                    .attr("stop-opacity", function(d) {
                        return d.opacity;
                    })
                    .attr("offset", function(d) {
                        var l = (me.controlPoints[me.controlPoints.length - 1].x - me.controlPoints[0].x);
                        return "" + ((d.x - me.controlPoints[0].x) / l * 100) + "%";
                    });

                gradient.exit().remove();

                if (d3.event) {
                    d3.event.preventDefault();
                    d3.event.stopPropagation();
                }

                // Override dirty checking
                var controlPoints = this.controlPoints;
                this.controlPoints = [];
                this.controlPoints = controlPoints;

                // Draw gradient in canvas too
                setTimeout(function() {
                    me._drawCanvas();
                }, 100);
            },

            /**
             * Draw the TF output in the canvas container.
             */
            _drawCanvas: function() {
                //var me = this;
                // var extent = [d3.min(this.controlPoints, function(d) {
                //         return d.x;
                //     }),
                //     d3.max(this.controlPoints, function(d) {
                //         return d.x;
                //     })
                // ];
                if (this.controlPoints != undefined && this.controlPoints.length > 0) {
                    var extent = [this.controlPoints[0].x, this.controlPoints[this.controlPoints.length - 1].x];
                    this.canvasScale.domain(extent);
                    // Convinient access
                    var x0 = extent[0],
                        x1 = extent[1];
                    var ctx = this.canvasContext();
                    // Clear previous result
                    ctx.clearRect(0, 0, 255, 10);
                    // Draw new result
                    var grd = ctx.createLinearGradient(x0, 0, x1, 0);
                    for (var i = 0; i < this.controlPoints.length; i++) {
                        var d = this.controlPoints[i];
                        //var d = this.get('controlPoints', i);
                        var color = d3.color(d.color);
                        color.opacity = d.opacity;
                        //grd.addColorStop((d.x - x0) / Math.abs(x1 - x0), color.toString());
                        grd.addColorStop(this.canvasScale(d.x), color.toString());
                    }
                    ctx.fillStyle = grd;
                    ctx.fillRect(x0, 0, x1 - x0, 10);

                    if (ctx.canvas.parentNode._x3domNode != undefined) {
                        ctx.canvas.parentNode._x3domNode.invalidateGLObject();
                    }
                }
            },

            /////// User interaction related event callbacks ////////

            _mousedown: function() {
                var me = this;
                var pos = d3.mouse(me.svg.node());
                point = {
                    "x": me.xScale.invert(pos[0] - me.margin.left),
                    "opacity": me.yScale.invert(pos[1] - me.margin.top),
                    "color": me.last_color
                };
                me.selected = me.dragged = point;
                var bisect = d3.bisector(function(a, b) {
                    return a.x - b.x;
                }).left;
                var indexPos = bisect(me.controlPoints, point);
                me.splice('controlPoints', indexPos, 0, point);
                me._redraw();
            },

            _mousemove: function() {
                if (!this.dragged) return;
                var index = this.controlPoints.indexOf(this.selected);
                var m = d3.mouse(this.svg.node());
                this.dragged.x = this.xScale.invert(Math.max(0, Math.min(this._width, m[0] - this.margin.left)));
                this.dragged.opacity = this.yScale.invert(Math.max(0, Math.min(this._height, m[1] - this.margin.top)));
                var bisect = d3.bisector(function(a, b) {
                    return a.x - b.x;
                }).left;
                var bisect2 = d3.bisector(function(a, b) {
                    return a.x - b.x;
                }).right;
                var virtualIndex = bisect(this.controlPoints, this.dragged);
                var virtualIndex2 = bisect2(this.controlPoints, this.dragged);
                if (virtualIndex < index) {
                    this.splice('controlPoints', virtualIndex, 1);
                } else if (virtualIndex > index) {
                    this.splice('controlPoints', index + 1, 1);
                } else if (virtualIndex2 - index >= 2) {
                    this.splice('controlPoints', index + 1, 1);
                }
                this._redraw();
            },

            _mouseup: function() {
                if (!this.dragged) return;
                this.dragged = null;
            },

            _keydown: function() {
                if (!this.selected) return;
                switch (d3.event.keyCode) {
                    case 46:
                        { // delete
                            var i = this.controlPoints.indexOf(this.selected);
                            this.splice('controlPoints', i, 1);
                            this.selected = this.controlPoints.length > 0 ? this.controlPoints[i > 0 ? i - 1 : 0] : null;
                            this._redraw();
                            break;
                        }
                }
            },

            /////// Public API functions ///////

            /**
             * Get the TF output canvas `element`.
             *
             * @return {HTMLElement} canvas 2D with the TF output.
             */
            getCanvas: function() {
                return this.$$(this.canvasselector);
            },
            /**
             * Get the output canvas `element` query selector.
             *
             * @return {CSSselector}
             */
            getcanvasselector: function() {
                return this.canvasselector;
            },
            /**
             * Set the output canvas `element`.
             *
             * @param {HTMLElement} element canvas 2D.
             * @return {bool}
             */
            setCanvas: function(element) {
                return this.canvasContext = element.getContext("2d");
            },
            /**
             * Set the output canvas `element`.
             *
             * @param {Array} d
             */
            setData: function(d) {},

            /////// Polymer lifecycle callbacks /////////////

            // Create elements when loaded into DOM not initialized
            created: function() {
                this._createElements();
            },

            // Initialize elements and perform the drawing of first drawing
            ready: function() {
                this.scopeSubtree(this.$.container, true);
                // Access the svg dom element
                this.svg = d3.select(this.$$('svg'));
                this._width = +this.svg.attr("width") - this.margin.left - this.margin.right;
                this._height = +this.svg.attr("height") - this.margin.top - this.margin.bottom - 15;
                // Create ramdom test data
                this._data = [0, 255];
                //this._data = d3.range(1000).map(d3.randomBates(10));
                this._initializeElements();
                this._drawChart();
            },

            attached: function() {
                //Check for init value in the selectors
                if (this.x3domselector != '') {
                    this._x3domselectorChanged(this.x3domselector, '');
                }
            },

            _isCanvasNeeded: function(canvasselector) {
                return canvasselector === '' || canvasselector === '#canvas-' + this.id;
            },

            // Define Polymer component properties
            properties: {
                /**
                 * Unique identifier for the dom element.
                 *
                 * @type {String}
                 */
                id: {
                    type: String,
                    value: 'tf-1',
                },
                /**
                 * Metadata describing a nome for the element (Optional).
                 *
                 * @type {String}
                 */
                name: {
                    type: String,
                    value: 'TF-Editor',
                },
                /**
                 * CSSselector to an ImageTexture node from the X3DOM Framework (Optional).
                 *
                 * @type {CSSselector}
                 */
                x3domselector: {
                    type: String,
                    value: '',
                    observer: '_x3domselectorChanged',
                },
                /**
                 * Explicit selector to an existent canvas (Optional).
                 * The referenced canvas must have a minimun width of 256
                 * pixels and 1 pixel height.
                 *
                 * @type {CSSselector}
                 */
                canvasselector: {
                    type: String,
                    value: '',
                    observer: '_canvasselectorChanged',
                },
                /**
                 * Computed property
                 * @type {Boolean}
                 */
                _external: {
                    type: Boolean,
                    computed: '_isCanvasNeeded(canvasselector)',
                },
                /**
                 * Explicit width fot the element (Optional).
                 *
                 * @type {Number}
                 */
                width: {
                    type: Number,
                    value: 375,
                },
                /**
                 * Explicit height fot the element (Optional).
                 *
                 * @type {Number}
                 */
                height: {
                    type: Number,
                    value: 200,
                },
                /**
                 * The number of bins to represent the histogram of the input data.
                 *
                 * @type {Number}
                 */
                numberBins: {
                    type: Number,
                    value: 100,
                },
                /**
                 * The number of ticks to be displayed in the axis.
                 *
                 * @type {Number}
                 */
                numberTicks: {
                    type: Number,
                    value: 4,
                },
                /**
                 * TF control points.
                 *
                 * The control points that define the transfer function. User
                 * added points will be reflected in the _control-points_
                 * attribute. Example:
                 *
                 *     [{"x":0,"opacity":0,"color":"blue"},
                 *      {"x":102.3,"opacity":0.55,"color":"green"},
                 *      {"x":255,"opacity":1,"color":"red"}]
                 * @type {Array}
                 */
                controlPoints: {
                    type: Array,
                    value: function() {
                        return [];
                    },
                    reflectToAttribute: true,
                    notify: true
                }
            },

            _x3domselectorChanged: function(newValue, oldValue) {
                if (newValue != undefined && newValue != "" && newValue != oldValue) {
                    console.log("New Selector added!");
                    console.log("New value: " + newValue);
                    console.log("Old value: " + oldValue);

                    console.log("Lookup for the voxel data");

                    console.log("Fechting the data");
                    var ctx = this;
                    var imageObj = new Image();
                    imageObj.onload = function() {
                        var imageFlattenArray = [];
                        var canvas = document.createElement('canvas');
                        var context = canvas.getContext('2d');
                        context.drawImage(this, 0, 0);
                        var imgData = context.getImageData(0, 0, this.width, this.height);
                        console.log("Flatten the pixel array");
                        // NOTE: We only keep the R channel
                        for (var i = 0, n = imgData.data.length; i < n; i += 4) {
                            imageFlattenArray.push(imgData.data[i]);
                        }
                        console.log("Set the new data");
                        ctx._data = imageFlattenArray;
                        ctx._redrawHistogram();
                    };
                    //Lookup for the volume data
                    var x3dNode = document.querySelector(newValue);
                    if (x3dNode != undefined && x3dNode.hasOwnProperty('_x3domNode')) {
                        var volumeDataUrl = '';
                        // If the provided selector refers to the OpacityMap
                        if (x3dNode.localName === "opacitymapvolumestyle") {
                            return;
                        } else if (x3dNode.localName === "blendedvolumestyle") {
                            return;
                        } else if (x3dNode.localName === "volumedata" || x3dNode.localName === "segmentedvolumedata" || x3dNode.localName === "isosurfacevolumedata") {
                            volumeDataUrl = x3dNode.querySelector("imagetextureatlas").getAttribute("url");
                            var tfTextureNode = x3dNode.querySelector("imagetexture");
                            if (tfTextureNode != undefined && tfTextureNode.getAttribute("url") != "") {
                                console.log("WARN: An image texture with a loaded TF founded.");
                            } else {
                                if (tfTextureNode.children.length > 0) {
                                    tfTextureNode.children[0].setAttribute("id", "tf-canvas-" + this.id);
                                } else {
                                    var canvas = createElement('canvas').setAttribute("id", "tf-canvas-" + this.id);
                                    tfTextureNode.append(canvas);
                                }
                                this.canvasselector = "#tf-canvas-" + this.id;
                            }
                            // Lool-up for the opacity
                        } else {
                            return;
                        }
                        imageObj.src = volumeDataUrl;
                    }
                }
            },

            _canvasselectorChanged: function(newValue, oldValue) {
                console.log("Check wheter the canvas is valid or not!");
            }
        });
    </script>
</dom-module>
