<!-- Manage external imports -->
<link rel="import" href="../polymer/polymer.html">
<script type="text/javascript" src="../d3/d3.min.js"></script>
<!--<link rel="import" href="/d3js/d3.html">-->

<!--
`tf-editor`
A Web based volume rendering transfer function editor

@demo demo/index.html
-->

<dom-module id="tf-editor">
  <template>
    <style>
      :host {
        display: block;
      }

      .bar rect {
        fill: steelblue;
      }

      .bar text {
        fill: #fff;
        font: 10px sans-serif;
      }

      rect {
        fill: none;
        pointer-events: all;
      }

      .line {
        fill: steelblue;
        stroke: black;
        stroke-width: 1.5px;
      }

      circle {
        fill: #fff;
        fill-opacity: .2;
        cursor: move;
        stroke: steelblue;
        stroke-width: 1.5px;
      }

      .selected {
        fill: #ff7f0e;
        stroke: #ff7f0e;
      }
    </style>
    <div id="container">
      <svg id="svg-{{id}}" width$="{{width}}" height$="{{height}}"></svg>
    </div>
  </template>

  <script>
    Polymer({

      is: 'tf-editor',

      createElements: function () {
        // Custom margins
        this.margin = {top: 10, right: 20, bottom: 20, left: 25};
        this.formatCount = d3.format(",.0f");

        // Axis scales
        this.xScale = d3.scaleLinear();
        this.yScale = d3.scaleLinear();
        this.binScale = d3.scaleLinear();

        // Interpolation line
        this.area = d3.area();

        // Create histogram object
        this.bins = d3.histogram();

        // Control points
        this.controlPoints = [];

        // Keep track of control points interaction
        this.dragged = null,
        this.selected = null;
      },

      initializeElements: function() {
        var extent = d3.extent(this._data);
        var me = this;
        this.xScale
          .rangeRound([0, this._width])
          .domain(extent);
        this.yScale
          .domain([0, 1])
          .range([this._height, 0]);
        this.binScale
          .range([this._height, 0]);
        this.bins
          .domain(this.xScale.domain())
          .thresholds(this.xScale.ticks(this.nbins));
        this.controlPoints.push([extent[0], 0]);
        this.controlPoints.push([extent[1], 1]);
        this.selected = this.controlPoints[0];
        this.area
          .x(function(d) { return me.xScale(d[0]); })
          .y0(function(d) { return me.yScale(d[1]); })
          .y1(this._height)
          .curve(d3.curveLinear);
      },

      // Perform the drawing
      drawChart: function () {
        var me = this;
        var g = this.svg.append("g")
            .attr("transform", "translate(" + this.margin.left + "," + this.margin.top + ")");

        // Add data to compute the histogram
        var bins = this.bins(this._data);
        this.binScale.domain([0, d3.max(bins, function(d) { return d.length; })])

        // Draw hitogram as a refence point
        var bar = g.selectAll(".bar")
          .data(bins)
          .enter().append("g")
            .attr("class", "bar")
            .attr("transform", function(d) { return "translate(" + me.xScale(d.x0) + "," + me.binScale(d.length) + ")"; });

        bar.append("rect")
            .attr("x", 1)
            .attr("width", this.xScale(bins[0].x1) - this.xScale(bins[0].x0) - 1)
            .attr("height", function(d) { return me._height - me.binScale(d.length); });

        // Draw control points
        g.append("path")
            .datum(me.controlPoints)
            .attr("class", "line")
            .attr("fill", "steelblue")
            .attr("opacity", 0.7)
            .attr("stroke", "black")
            .call(function(){var _that = me; me.redraw.call(_that);});

        g.append("rect")
            .attr("width", me._width)
            .attr("height", me._height)
            .style("opacity", 0)
            .on("mousedown", function(){var _that = me; me.mousedown.call(_that);})
            .on("mouseup", function(){var _that = me; me.mouseup.call(_that);})
            .on("mousemove", function(){var _that = me; me.mousemove.call(_that);});

        d3.select(me.$$('svg')).on("keydown", function(){var _that = me; me.keydown.call(_that);});

        // Draw axis
        g.append("g")
            .attr("class", "axis axis--x")
            .attr("transform", "translate(0," + me._height + ")")
            .call(d3.axisBottom(me.xScale));

        g.append("g")
            .attr("class", "axis axis--y")
            .attr("transform", "translate(0, 0)")
            .call(d3.axisLeft(me.yScale));
      },

      // Update the chart content
      redraw: function() {
        var me = this;
        var svg = d3.select(me.$$('svg')).select("g");
        svg.select("path").attr("d", me.area);

        var circle = svg.selectAll("circle")
            .data(me.controlPoints)

        circle.enter().append("circle")
            .attr("cx", function(d) { return me.xScale(d[0]); })
            .attr("cy", function(d) { return me.yScale(d[1]); })
            .attr("r", 1e-6)
            .on("mousedown", function(d) { var _that = me; me.selected = me.dragged = d; me.redraw.call(_that); })
            .on("mouseup", function(){var _that = me; me.mouseup.call(_that);})
          .transition()
            .duration(750)
            //.ease("elastic")
            .attr("r", 5.0);

        circle.classed("selected", function(d) { return d === me.selected; })
            .attr("cx", function(d) { return me.xScale(d[0]); })
            .attr("cy", function(d) { return me.yScale(d[1]); });

        circle.exit().remove();

        if (d3.event) {
          d3.event.preventDefault();
          d3.event.stopPropagation();
        }
      },

      // Refresh the control points
      refresh: function() {

      },

      /////// User interaction related event callbacks ////////

      mousedown: function(){
        var me = this;
        var pos = d3.mouse(me.svg.node());
        pos = [
          me.xScale.invert(pos[0] - me.margin.left),
          me.yScale.invert(pos[1] - me.margin.top)
        ];
        me.selected = me.dragged = pos;
        var bisect = d3.bisector(function(a, b) { return a[0] - b[0]; }).left;
        var indexPos = bisect(me.controlPoints, pos);
        me.controlPoints.splice(indexPos, 0, pos);
        me.redraw.call(me);
      },

      mousemove: function() {
        if (!this.dragged) return;
        var index = this.controlPoints.indexOf(this.selected);
        var m = d3.mouse(this.svg.node());
        this.dragged[0] = this.xScale.invert(Math.max(0, Math.min(this._width, m[0] - this.margin.left)));
        this.dragged[1] = this.yScale.invert(Math.max(0, Math.min(this._height, m[1] - this.margin.top)));
        var bisect = d3.bisector(function(a, b) { return a[0] - b[0]; }).left;
        var bisect2 = d3.bisector(function(a, b) { return a[0] - b[0]; }).right;
        var virtualIndex = bisect(this.controlPoints, this.dragged);
        var virtualIndex2 = bisect2(this.controlPoints, this.dragged);
        if (virtualIndex<index) {
          this.controlPoints.splice(virtualIndex, 1);
        }else if (virtualIndex>index) {
          this.controlPoints.splice(index+1, 1);
        }else if (virtualIndex2-index >= 2) {
          this.controlPoints.splice(index+1, 1);
        }
        this.redraw.call(this);
      },

      mouseup: function() {
        if (!this.dragged) return;
        this.redraw.call(this);
        this.dragged = null;
      },

      keydown: function(){
        if (!this.selected) return;
        switch (d3.event.keyCode) {
          case 46: { // delete
            var i = this.controlPoints.indexOf(this.selected);
            this.controlPoints.splice(i, 1);
            this.selected = this.controlPoints.length ?  this.controlPoints[i > 0 ? i - 1 : 0] : null;
            this.redraw.call(this);
            break;
          }
        }
      },

      /////// Polymer lifecycle callbacks /////////////

      // Initialize elements when loaded into DOM
      created: function() {
        this.createElements();
      },

      // Perform the drawing of the transfer function
      ready: function() {
        this.scopeSubtree(this.$.container, true);
        // Access the svg dom element
        this.svg = d3.select(this.$$('svg'));
        this._width = +this.svg.attr("width") - this.margin.left - this.margin.right;
        this._height = +this.svg.attr("height") - this.margin.top - this.margin.bottom;
        // Create ramdom test data
        this._data = d3.range(1000).map(function(){return Math.random() * 255 | 0;});
        //this._data = d3.range(1000).map(d3.randomBates(10));
        this.initializeElements();
        this.drawChart();
      },

      // Define Polymer component properties
      properties: {
        id: {
          type: String,
          value: 'tf-1',
        },
        name: {
          type: String,
          value: 'TF-Editor',
        },
        width: {
          type: Number,
          value: 375,
        },
        height: {
          type: Number,
          value: 200,
        },
        nbins: {
          type: Number,
          value: 100,
        },
        interpolate: {
          type: String,
          value: "linear"
        }
      },

    });
  </script>
</dom-module>
