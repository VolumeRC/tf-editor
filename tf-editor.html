<!-- Manage external imports -->
<link rel="import" href="../polymer/polymer.html">
<script type="text/javascript" src="../d3/d3.min.js"></script>

<!--
`<tf-editor>`
A Web based volume rendering transfer function editor

Typical use, just insert `<tf-editor>` along a volume rendering scene into your
page and then pass the volume data as a flatten array as an input.

    <body>
      <tf-editor id="TF"></tf-editor>
    </body>

The output canvas selector string will be reflected in the `output` attribute.

@demo ./demo/index.html  Showcase of the different attribute arguments!
@demo ./demo/demo1.html  Super cool demo, TF with volume rendering exanple!
@demo ./demo/demo2.html  Even cooler demo. TF with DICOM and rescale example!
-->
<dom-module id="tf-editor">
  <template>
    <style>
      :host {
        display: block;
      }

      .bar rect {
        fill: steelblue;
      }

      rect {
        fill: none;
        pointer-events: all;
      }

      .line {
        /*fill: steelblue;*/
        stroke: black;
        stroke-width: 1.5px;
      }

      circle {
        /*fill: #fff;*/
        fill-opacity: .6;
        cursor: move;
        stroke: black;
        stroke-width: 1.5px;
      }

      .selected {
        fill: #ff7f0e;
        stroke: #ff7f0e;
      }
    </style>
    <div id="container">
      <svg id="svg-{{id}}" width$="{{width}}" height$="{{height}}"></svg>
      <input type="color" id="picker-{{id}}"><canvas id="canvas-{{id}}" width="255" height="10"></canvas>
    </div>
  </template>

  <script>
    Polymer({

      is: 'tf-editor',

      createElements: function () {
        // Custom margins
        this.margin = {top: 10, right: 20, bottom: 20, left: 25};
        this.formatCount = d3.format(",.0f");

        // Axis scales
        this.xScale = d3.scaleLinear();
        this.yScale = d3.scaleLinear();
        this.binScale = d3.scaleLinear();

        // Interpolation line
        this.area = d3.area();

        // Create histogram object
        this.bins = d3.histogram();

        // Control points
        this.controlPoints = [];

        // Keep track of control points interaction
        this.dragged = null,
        this.selected = null;
        this.last_color = 'green';
      },

      initializeElements: function() {
        var extent = d3.extent(this._data);
        var me = this;
        this.xScale
          .rangeRound([0, this._width])
          .domain(extent);
        this.yScale
          .domain([0, 1])
          .range([this._height, 0]);
        this.binScale
          .range([this._height, 0]);
        this.bins
          .domain(this.xScale.domain())
          .thresholds(this.xScale.ticks(this.nbins));
        this.controlPoints.push({'x':extent[0], 'opacity':0, 'color': 'blue'});
        this.controlPoints.push({'x':extent[1], 'opacity':1, 'color': 'red'});
        this.selected = this.controlPoints[0];
        this.area
          .x(function(d) { return me.xScale(d.x); })
          .y0(function(d) { return me.yScale(d.opacity); })
          .y1(this._height)
          .curve(d3.curveLinear);
        // Get the context of the canvas element
        this.canvasContext = this.$$("canvas").getContext("2d");
        // Access the color selector
        this.$$("#picker-"+this.id).addEventListener("change", function(){
            me.last_color = this.value;
        });
      },

      // Perform the drawing
      drawChart: function () {
        var me = this;
        var g = this.svg.append("g")
            .attr("transform", "translate(" + this.margin.left + "," + this.margin.top + ")");

        // Add data to compute the histogram
        var bins = this.bins(this._data);
        this.binScale.domain([0, d3.max(bins, function(d) { return d.length; })])

        // Draw hitogram as a refence point
        var bar = g.selectAll(".bar")
          .data(bins)
          .enter().append("g")
            .attr("class", "bar")
            .attr("transform", function(d) { return "translate(" + me.xScale(d.x0) + "," + me.binScale(d.length) + ")"; });

        bar.append("rect")
            .attr("x", 1)
            .attr("width", this.xScale(bins[0].x1) - this.xScale(bins[0].x0) - 1)
            .attr("height", function(d) { return me._height - me.binScale(d.length); });

        // Gradient definitions
        g.append("defs").append("linearGradient")
          .attr("id", "tfGradient-"+this.id)
          //.attr("gradientUnits", "userSpaceOnUse")
          .attr("gradientUnits", "objectBoundingBox")
          .attr("spreadMethod", "pad")
          .attr("x1", "0%").attr("y1", "0%")
          .attr("x2", "100%").attr("y2", "0%");
          //.attr("x1", me.xScale(0)).attr("y1", me.yScale(0))
          //.attr("x2", me.xScale(255)).attr("y2", me.yScale(0));

        // Draw control points
        g.append("path")
            .datum(me.controlPoints)
            .attr("class", "line")
            .attr("fill", "url(#tfGradient-"+this.id+")")
            .attr("stroke", "black")
            .call(function(){var _that = me; me.redraw.call(_that);});

        g.append("rect")
            .attr("width", me._width)
            .attr("height", me._height)
            .style("opacity", 0)
            .on("mousedown", function(){var _that = me; me.mousedown.call(_that);})
            .on("mouseup", function(){var _that = me; me.mouseup.call(_that);})
            .on("mousemove", function(){var _that = me; me.mousemove.call(_that);});

        d3.select(me.$$('svg')).on("keydown", function(){var _that = me; me.keydown.call(_that);});

        // Draw axis
        g.append("g")
            .attr("class", "axis axis--x")
            .attr("transform", "translate(0," + me._height + ")")
            .call(d3.axisBottom(me.xScale).ticks(4));

        g.append("g")
            .attr("class", "axis axis--y")
            .attr("transform", "translate(0, 0)")
            .call(d3.axisLeft(me.yScale).ticks(5));
      },

      // Update the chart content
      redraw: function() {
        var me = this;
        var svg = d3.select(me.$$('svg')).select("g");
        svg.select("path").attr("d", me.area);

        // Add circle to connect and interact with the control points
        var circle = svg.selectAll("circle")
            .data(me.controlPoints)

        circle.enter().append("circle")
            .attr("cx", function(d) { return me.xScale(d.x); })
            .attr("cy", function(d) { return me.yScale(d.opacity); })
            .style("fill", function(d) { return d.color; })
            .attr("r", 1e-6)
            .on("mousedown", function(d) {
                var _that = me;
                me.selected = me.dragged = d;
                me.last_color = d.color;
                me.redraw.call(_that);
            })
            .on("mouseup", function(){var _that = me; me.mouseup.call(_that);})
            .on("contextmenu", function (d, i) {
                // react on right-clicking
                d3.event.preventDefault();
                d.color = me.$$("#picker-"+me.id).value;
                me.redraw.call(me);
            })
          .transition()
            .duration(750)
            .attr("r", 5.0);

        circle.classed("selected", function(d) { return d === me.selected; })
            .style("fill", function(d) { return d.color; })
            .attr("cx", function(d) { return me.xScale(d.x); })
            .attr("cy", function(d) { return me.yScale(d.opacity); })
            .raise();

        circle.exit().remove();

        // Create a linear gradient definition of the control points
        var gradient = svg.select("linearGradient").selectAll("stop").data(me.controlPoints);

        gradient.enter().append("stop")
            .attr("stop-color", function(d) {return d.color; })
            .attr("stop-opacity", function(d) { return d.opacity; })
            .attr("offset", function(d) { var l=(me.controlPoints[me.controlPoints.length-1].x - me.controlPoints[0].x);return ""+((d.x-me.controlPoints[0].x)/l*100)+"%"; });

        gradient.attr("stop-color", function(d) {return d.color; })
            .attr("stop-opacity", function(d) { return d.opacity; })
            .attr("offset", function(d) { var l=(me.controlPoints[me.controlPoints.length-1].x - me.controlPoints[0].x);return ""+((d.x-me.controlPoints[0].x)/l*100)+"%"; });

        gradient.exit().remove();

        if (d3.event) {
          d3.event.preventDefault();
          d3.event.stopPropagation();
        }

        // Draw gradient in canvas too
        setTimeout(function(){
          me.drawCanvas(me);
        }, 100);
      },

      // Refresh the control points
      refresh: function() {

      },

      // Draw thre tf gradient in the canvas container
      drawCanvas: function(){
        var ctx = this.canvasContext;
        ctx.clearRect(0,0,255,10);
        var x0 = this.controlPoints[0].x,
          x2 = this.controlPoints[this.controlPoints.length-1].x;
        var grd = ctx.createLinearGradient(x0,0,x2,0);
        this.controlPoints.forEach(function(d){
          var color = d3.color(d.color);
          color.opacity = d.opacity;
          grd.addColorStop(d.x/256, color.toString());
        });
        ctx.fillStyle=grd;
        ctx.fillRect(x0,0,x2,10);
      },

      /////// User interaction related event callbacks ////////

      mousedown: function(){
        var me = this;
        var pos = d3.mouse(me.svg.node());
        point = {
          'x': me.xScale.invert(pos[0] - me.margin.left),
          'opacity': me.yScale.invert(pos[1] - me.margin.top),
          'color': me.last_color
        };
        me.selected = me.dragged = point;
        var bisect = d3.bisector(function(a, b) { return a.x - b.x; }).left;
        var indexPos = bisect(me.controlPoints, point);
        me.controlPoints.splice(indexPos, 0, point);
        me.redraw.call(me);
      },

      mousemove: function() {
        if (!this.dragged) return;
        var index = this.controlPoints.indexOf(this.selected);
        var m = d3.mouse(this.svg.node());
        this.dragged.x = this.xScale.invert(Math.max(0, Math.min(this._width, m[0] - this.margin.left)));
        this.dragged.opacity = this.yScale.invert(Math.max(0, Math.min(this._height, m[1] - this.margin.top)));
        var bisect = d3.bisector(function(a, b) { return a.x - b.x; }).left;
        var bisect2 = d3.bisector(function(a, b) { return a.x - b.x; }).right;
        var virtualIndex = bisect(this.controlPoints, this.dragged);
        var virtualIndex2 = bisect2(this.controlPoints, this.dragged);
        if (virtualIndex<index) {
          this.controlPoints.splice(virtualIndex, 1);
        }else if (virtualIndex>index) {
          this.controlPoints.splice(index+1, 1);
        }else if (virtualIndex2-index >= 2) {
          this.controlPoints.splice(index+1, 1);
        }
        this.redraw.call(this);
      },

      mouseup: function() {
        if (!this.dragged) return;
        this.redraw.call(this);
        this.dragged = null;
      },

      keydown: function(){
        if (!this.selected) return;
        switch (d3.event.keyCode) {
          case 46: { // delete
            var i = this.controlPoints.indexOf(this.selected);
            this.controlPoints.splice(i, 1);
            this.selected = this.controlPoints.length ?  this.controlPoints[i > 0 ? i - 1 : 0] : null;
            this.redraw.call(this);
            break;
          }
        }
      },

      /////// Polymer lifecycle callbacks /////////////

      // Initialize elements when loaded into DOM
      created: function() {
        this.createElements();
      },

      // Perform the drawing of the transfer function
      ready: function() {
        this.scopeSubtree(this.$.container, true);
        // Access the svg dom element
        this.svg = d3.select(this.$$('svg'));
        this._width = +this.svg.attr("width") - this.margin.left - this.margin.right;
        this._height = +this.svg.attr("height") - this.margin.top - this.margin.bottom-15;
        // Create ramdom test data
        this._data = d3.range(1000).map(function(){return Math.random() * 255 | 0;});
        //this._data = d3.range(1000).map(d3.randomBates(10));
        this.initializeElements();
        this.drawChart();
      },

      // Define Polymer component properties
      properties: {
        id: {
          type: String,
          value: 'tf-1',
        },
        name: {
          type: String,
          value: 'TF-Editor',
        },
        width: {
          type: Number,
          value: 375,
        },
        height: {
          type: Number,
          value: 200,
        },
        nbins: {
          type: Number,
          value: 100,
        },
        interpolate: {
          type: String,
          value: "linear"
        }
      },

    });
  </script>
</dom-module>
